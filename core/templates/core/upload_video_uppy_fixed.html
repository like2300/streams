<!-- Version corrig√©e du template upload_video_uppy.html -->
{% extends 'base.html' %}

{% block title %}Uploader une Vid√©o - StreamApp{% endblock %}

{% block content %}
<h1 class="text-3xl font-bold mb-2">üé¨ Uploader une Vid√©o</h1>
<p class="text-gray-600 mb-6">Remplissez les informations, puis glissez-d√©posez votre vid√©o.</p>

<div class="flex flex-col lg:flex-row gap-8">
    <!-- Formulaire metadonn√©es -->
    <div class="lg:w-1/3">
        <form id="upload-form" class="space-y-4 bg-gray-50 p-4 rounded-lg">
            <div>
                <label for="video-title" class="block text-sm font-medium text-gray-700">Titre *</label>
                <input type="text" id="video-title" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div>
                <label for="video-description" class="block text-sm font-medium text-gray-700">Description</label>
                <textarea id="video-description" rows="4" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"></textarea>
            </div>
            <div>
                <label for="video-category" class="block text-sm font-medium text-gray-700">Cat√©gorie</label>
                <select id="video-category" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                    <option value="">-- S√©lectionner --</option>
                    {% for category in categories %}
                        <option value="{{ category.id }}">{{ category.name }}</option>
                    {% endfor %}
                </select>
            </div>
            <div>
                <label for="cover-input" class="block text-sm font-medium text-gray-700">Image de couverture (optionnel)</label>
                <input type="file" id="cover-input" accept="image/*" class="mt-1 block w-full">
            </div>
            <div>
                <label for="video-duration" class="block text-sm font-medium text-gray-700">Dur√©e (secondes)</label>
                <input type="number" id="video-duration" min="0" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>
        </form>
    </div>

    <!-- Uppy Dashboard -->
    <div class="lg:w-2/3">
        <div class="bg-white rounded-lg shadow-md p-6">
            <div id="uppy-dashboard"></div>
        </div>
        <div id="upload-status" class="mt-4 p-4 rounded-lg hidden"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<link href="https://releases.transloadit.com/uppy/v3.3.1/uppy.min.css" rel="stylesheet">
<script src="https://releases.transloadit.com/uppy/v3.3.1/uppy.min.js"></script>

<script>
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Fonction pour afficher les statuts
function showStatus(message, type) {
    const statusDiv = document.getElementById('upload-status');
    statusDiv.className = `mt-4 p-4 rounded-lg ${
        type === 'success' 
        ? 'bg-green-100 text-green-700 border border-green-300' 
        : 'bg-red-100 text-red-700 border border-red-300'
    }`;
    statusDiv.textContent = message;
    statusDiv.classList.remove('hidden');
}

document.addEventListener('DOMContentLoaded', function() {
    const presignKeyMap = {};
    const presignPublicRootMap = {};

    // Configuration de Uppy avec gestion am√©lior√©e des erreurs
    const uppy = new Uppy.Uppy({
        debug: true, // Activer le debug pour voir les erreurs
        autoProceed: false,
        restrictions: { 
            maxFileSize: 2 * 1024 * 1024 * 1024, 
            maxNumberOfFiles: 1, 
            allowedFileTypes: ['video/*'] 
        },
        locale: {
            strings: {
                // Traductions pour les messages d'erreur
                uploadFailed: '√âchec de l'upload',
                crashed: 'Une erreur s'est produite',
                error: 'Erreur',
                complete: 'Termin√©'
            }
        }
    })
    .use(Uppy.Dashboard, { 
        inline: true, 
        target: '#uppy-dashboard', 
        showProgressDetails: true, 
        proudlyDisplayPoweredByUppy: false,
        note: 'Vid√©os jusqu'√† 2 Go, formats vid√©o support√©s'
    })
    .use(Uppy.AwsS3, {
        limit: 1,
        timeout: 600000, // 10 minutes timeout
        getUploadParameters(file) {
            // Afficher les d√©tails du fichier pour le d√©bogage
            console.log('Pr√©paration de l'upload pour:', file.name, file.type);
            
            return fetch('{% url "s3_presign" %}', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken') 
                },
                body: JSON.stringify({ 
                    filename: file.name, 
                    contentType: file.type, 
                    uploadType: 'videos' 
                })
            })
            .then(response => {
                // V√©rifier si la r√©ponse est OK
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('R√©ponse presign:', data);
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Sauvegarder la cl√© et la racine publique pour ce fichier
                presignKeyMap[file.id] = data.key;
                presignPublicRootMap[file.id] = (data.public_root || data.url).replace(/\/$/, '');
                
                // Retourner les param√®tres d'upload presign√©s
                return { 
                    method: data.method || 'POST', 
                    url: data.url, 
                    fields: data.fields 
                };
            })
            .catch(error => {
                console.error('Erreur lors de l'obtention des param√®tres d'upload:', error);
                uppy.info(`Erreur de pr√©paration de l'upload: ${error.message}`, 'error');
                throw error;
            });
        }
    });

    // Gestion de l'√©v√©nement d'upload r√©ussi
    uppy.on('upload-success', (file, response) => {
        console.log('Upload r√©ussi:', file, response);
        
        const key = presignKeyMap[file.id];
        const publicRoot = presignPublicRootMap[file.id];
        
        if (!key || !publicRoot) {
            console.error('Cl√© ou racine publique manquante');
            uppy.info('Erreur: donn√©es presign√©es manquantes', 'error');
            return;
        }
        
        // URL finale du fichier
        const fileURL = `${publicRoot}/${key}`;
        console.log('URL du fichier:', fileURL);
        
        // Gestion du fichier de couverture si pr√©sent
        const coverFile = document.getElementById('cover-input').files[0];
        if (coverFile) {
            // Obtenir un presign pour le fichier de couverture
            fetch('{% url "s3_presign" %}', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json', 
                    'X-CSRFToken': getCookie('csrftoken') 
                },
                body: JSON.stringify({ 
                    filename: `cover_${Date.now()}_${coverFile.name}`, 
                    contentType: coverFile.type, 
                    uploadType: 'covers' 
                })
            })
            .then(response => response.json())
            .then(async presign => {
                if (presign.error) {
                    throw new Error(presign.error);
                }
                
                // Cr√©er le formulaire multipart pour l'upload de l'image
                const form = new FormData();
                Object.entries(presign.fields).forEach(([k, v]) => form.append(k, v));
                form.append('file', coverFile);
                
                // Faire l'upload du fichier de couverture
                await fetch(presign.url, { 
                    method: 'POST', 
                    body: form 
                });
                
                const coverPublicRoot = (presign.public_root || presign.url).replace(/\/$/, '');
                const coverURL = `${coverPublicRoot}/${presign.key || presign.fields.key}`;
                
                console.log('URL du fichier de couverture:', coverURL);
                
                // Finaliser l'upload avec les deux URLs
                finalize(fileURL, coverURL);
            })
            .catch(error => {
                console.error('Erreur lors de l'upload de la couverture:', error);
                // Continuer avec l'upload principal sans image de couverture
                finalize(fileURL, null);
            });
        } else {
            // Finaliser sans image de couverture
            finalize(fileURL, null);
        }
    });

    // Gestion des erreurs d'upload
    uppy.on('upload-error', (file, error) => {
        console.error('Erreur d'upload:', file, error);
        showStatus(`Erreur lors de l'upload de ${file.name}: ${error.message}`, 'error');
    });

    // Gestion des erreurs r√©seau
    uppy.on('error', (error) => {
        console.error('Erreur g√©n√©rale:', error);
        showStatus(`Erreur g√©n√©rale: ${error.message}`, 'error');
    });

    // Fonction de finalisation de l'upload
    function finalize(fileURL, coverURL) {
        const title = document.getElementById('video-title') ? document.getElementById('video-title').value.trim() : '';
        
        if (!title) { 
            uppy.info('Veuillez entrer un titre', 'error'); 
            return; 
        }
        
        console.log('Finalisation de l'upload...');
        
        // Envoyer la requ√™te de finalisation
        fetch('{% url "finalize_upload" %}', {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json', 
                'X-CSRFToken': getCookie('csrftoken') 
            },
            body: JSON.stringify({
                uploadType: 'video',
                fileURL: fileURL,
                cover_image: coverURL,
                title: title,
                description: document.getElementById('video-description')?.value || '',
                category: document.getElementById('video-category')?.value || null,
                duration: parseInt(document.getElementById('video-duration')?.value) || 0
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Erreur serveur: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Finalisation r√©ussie:', data);
            if (data.success) { 
                uppy.info(data.message, 'success'); 
                showStatus(data.message, 'success');
                setTimeout(() => window.location.href = data.url, 1200); 
            } else { 
                throw new Error(data.error || 'Erreur serveur'); 
            }
        })
        .catch(error => {
            console.error('Erreur lors de la finalisation:', error);
            const errorMessage = `Erreur de finalisation: ${error.message}`;
            uppy.info(errorMessage, 'error');
            showStatus(errorMessage, 'error');
        });
    }
});
</script>
{% endblock %}